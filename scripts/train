#!/usr/bin/env node

const F = require("../framework.js");
const program = require("commander");
const axios = require("axios");
const $ = require("cheerio");
const colors = require("colors");
const moment = require("moment");
const fs = require("fs");
const path = require("path");
const shell = require("shelljs");
const Table = require("easy-table");

class Station {
  constructor({ id, title, hebTitle }) {
    this.id = id;
    this.title = title;
    this.hebTitle = hebTitle;
    this.name = title
      .toLowerCase()
      .replace(/\(.*$/, "")
      .replace(/'/g, "")
      .trim()
      .replace(/\s/g, "-");
  }

  print() {
    const comment = colors.grey(`(${this.id} ${this.title})`);
    console.info(`${this.name} ${comment}`);
  }
}

class StationRepository {
  constructor() {
    this._stations = null;
    this._cacheFilename = path.join(
      process.env.HOME,
      ".cache/dotfiles/stations.json"
    );
  }

  fetch() {
    if (this._stations != null) {
      return Promise.resolve(this._stations);
    }

    this._stations = this._loadFromCache();
    if (this._stations != null) {
      return Promise.resolve(this._stations);
    }

    F.printProgress("Fetching stations");
    return this._loadFromServer().then(stations => {
      F.clearLine();
      this._stations = stations;
      this._saveToCache();
      return stations;
    });
  }

  findByName(name) {
    this.fetch().then(stations => {
      return stations.find(s => s.name === name);
    });
  }

  _loadFromCache() {
    try {
      fs.statSync(this._cacheFilename);
    } catch (e) {
      return null;
    }

    return JSON.parse(fs.readFileSync(this._cacheFilename)).map(
      attribs => new Station(attribs)
    );
  }

  _saveToCache() {
    const cacheDir = path.dirname(this._cacheFilename);
    shell.mkdir("-p", cacheDir);

    fs.writeFileSync(
      this._cacheFilename,
      JSON.stringify(this._stations, null, 2)
    );
  }

  _loadFromServer() {
    return axios.get("https://www.rail.co.il").then(response => {
      const match = response.data.match(/var stationSegRes=(.*);var/);
      if (match == null) {
        throw new Error("Can't load stations");
      }

      const raw = JSON.parse(match[1]);
      return raw.Data.Data.CustomPropertys.map(rawStation => {
        return new Station({
          id: rawStation.Id,
          title: rawStation.Eng.join(", "),
          hebTitle: rawStation.Heb.join(", ")
        });
      });
    });
  }
}

class Train {
  constructor($tr) {
    const tds = $tr.find("> td");

    Object.assign(this, {
      departure: $(tds[1]).text(),
      arrival: $(tds[2]).text(),
      duration: $(tds[3]).text(),
      changing: $(tds[4]).text()
    });
  }

  print() {
    let message = `${this.departure} => ${this.arrival}\t (elapsed: ${this
      .duration})`;

    if (this.changing !== "Without changing") {
      message += ` (${this.changing})`;
    }

    console.info(message);
  }

  addToTable(table) {
    table.cell("Departure", this.departure);
    table.cell("Arrival", this.arrival);
    table.cell("Duration", this.duration);
    table.cell("Details", this.changing);
    table.newRow();
  }

  static fetch(originId, destId, departure = moment()) {
    if (typeof departure === "string") {
      departure = this.parseTime(departure);
    }

    const url = "http://www.rail.co.il/EN/DrivePlan/Pages/DrivePlan.aspx";

    F.printProgress("Fetching trains");
    return axios
      .get(url, {
        params: {
          OriginStationId: originId,
          DestStationId: destId,
          HoursDeparture: departure.hours(),
          MinutesDeparture: departure.minutes(),
          GoingTrainCln: departure.format("YYYY-MM-DD"),
          GoingHourDeparture: true
        }
      })
      .then(response => {
        F.clearLine();
        // Uncomment this line to debug the parser
        // fs.writeFileSync("trains.html", response.data)
        return this.parse(response.data);
      });
  }

  static parse(html) {
    const $html = $.load(html);
    const rows = $html("tr[name=TrainRow]").toArray();
    return rows.map(tr => new Train($(tr)));
  }

  static parseTime(time) {
    let parsed = moment(time, "YYYY-MM-DD HH:mm");
    if (parsed.isValid()) {
      return parsed;
    }

    parsed = moment(time, "HH:mm");
    if (parsed.isValid()) {
      return parsed;
    }

    return null;
  }
}

class CLI {
  constructor() {
    this.repo = new StationRepository();
  }

  fetchTrains(origin, dest, time) {
    this.repo
      .fetch()
      .then(stations => {
        const originId = stations.find(s => s.name === origin).id;
        const destId = stations.find(s => s.name === dest).id;

        return Train.fetch(originId, destId, time).then(trains => {
          console.info(`Found ${trains.length} trains:\n`);
          const table = new Table();
          trains.forEach(t => t.addToTable(table));
          console.info(table.toString());
        });
      })
      .catch(e => {
        console.error(e);
      });
  }

  listStations() {
    return this.repo.fetch().then(stations => {
      stations.forEach(station => station.print());
    });
  }
}

const cli = new CLI();

program
  .arguments("<origin> <dest> [time]")
  .option("-l --list", "list all stations")
  .action((origin, dest, time) => {
    cli.fetchTrains(origin, dest, time);
  })
  .parse(process.argv);

if (program.list) {
  cli.listStations().catch(e => console.error(e));
}
