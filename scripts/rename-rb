#!/usr/bin/env ruby

require "#{ENV['DOTF']}/framework.rb"
require 'fileutils'

class CLI < OptionsCLI
  desc 'Renames filenames'
  usage 'rename [options] <pattern> <replacement> <file>...'
  min_items 3
  cli_options \
    yes: ['-y', '--yes', "Don't ask for confirmation"]

  def start
    @pattern = Regexp.new(ARGV.shift, 'ig')
    @replacement = ARGV.shift

    if matches.empty?
      puts 'No matches'
    else
      matches.each{ |m| m.print('   ') }
      puts
      rename! if options[:yes] || confirm?('Rename?')
    end
  end

  private

  def matches
    @matches ||= [].tap do |matches|
      ARGV.each do |filename|
        basename = File.basename(filename)
        new_basename = basename.gsub(@pattern, @replacement)
        matches << Match.new(filename, new_basename) if basename != new_basename
      end
    end
  end

  def rename!
    @matches.each do |match|
      match.print 'Renaming '
      match.rename!
    end
  end
end

class Match
  def initialize(from_fullpath, to_basename)
    @from_fullpath = from_fullpath
    @to_basename = to_basename
    @from_dirname = File.dirname(from_fullpath)
    @from_basename = File.basename(from_fullpath)
    @to_fullpath = File.join(@from_dirname, @to_basename)
  end

  def indent(prefix)
    ' ' * [prefix.length + @from_dirname.length - 3, 0].max
  end

  def print(prefix = '')
    puts "#{prefix}#{gray(@from_dirname)}/#{@from_basename}"
    puts "#{indent(prefix)} => #{blue(@to_basename)}"
  end

  def rename!
    if git?
      system "git mv '#{@from_fullpath}' '#{@to_fullpath}'"
    else
      FileUtils.mv @from_fullpath, @to_fullpath
    end
  end

  def git?
    system("git ls-files --error-unmatch #{@from_fullpath} > /dev/null 2>&1")
  end
end

CLI.new.start
