#!/usr/bin/env ruby

require "#{ENV['DOTF']}/lib/git.rb"

class CLI
  def initialize
    @repo = Repo.new(ARGV[0] || '.')
    @repo.fetch_all
    puts
    report_local_branches_without_remote
    report_remote_branches_without_local
    report_unsynced_branches
  end

  def report_local_branches_without_remote
    return if @repo.local_branches_without_remote.empty?

    puts red('Local branches without remote:')
    @repo.local_branches_without_remote.each { |_, branch| puts "* #{branch}" }
    puts
  end

  def report_remote_branches_without_local
    return if @repo.remote_branches_without_local.empty?

    puts red('Remote branches without local:')
    @repo.remote_branches_without_local.each { |_, branch| puts "* #{branch}" }
    puts
  end

  def report_unsynced_branches
    return if @repo.unsynced_branches.empty?

    puts red('Unsynced branches without remote:')
    @repo.unsynced_branches.each do |pair|
      puts "* #{pair}"
    end
    puts

    @repo.unsynced_branches.each do |pair|
      pair.sync! if confirm?(yellow("Sync #{pair}?"))
    end
  end
end

class Pair
  def initialize(local, remote)
    @local = local
    @remote = remote
  end

  def to_s
    "#{@local} <=> #{@remote}"
  end

  def sync!
    puts blue("* Synchronizing #{self}")

    puts green("  * Checking out branch #{@local}")
    git "checkout #{@local}"

    pull

    return if synced?

    if !@local.protected? || confirm?(yellow("Push to #{@remote}?"))
      push
    end
  end

  def pull
    puts green("  * Pulling from #{remote_arg}")

    begin
      git "pull --rebase=false --ff-only #{remote_arg}"
      @local.reset_hash!
      @remote.reset_hash!
    rescue GitError
      pull_alternatives
    end
  end

  def pull_alternatives
    case pick_alternative
    when 'rebase'
      git "pull --rebase #{remote_arg}"
    when 'reset'
      git "reset --hard #{@remote}"
    when 'pushf'
      git "push -f #{remote_arg}"
    end
  end

  def pick_alternative
    puts red("Can't fast forward, these are the changes:")
    show_diff

    puts yellow('These are your options:')
    puts "  [rebase] Do a pull with rebase (#{@local} <= #{@remote})"
    puts "  [reset]  Do a hard reset       (#{@local} <= #{@remote})"
    puts "  [pushf]  Do a push -f          (#{@local} => #{@remote})"
    ask yellow('What would you like to do?')
  end

  def remote_arg
    "#{@remote.remote_name} #{@remote.name}"
  end

  def push
    puts green("  * Pushing to #{remote_arg}")
    git "push #{remote_arg}"

    puts
  end

  def show_diff
    local_info = git("show --no-patch --format='(%s) %cr' #{@local}")
    print yellow("Local:  #{local_info}")

    remote_info = git("show --no-patch --format='(%s) %cr' #{@remote}")
    print yellow("Remote: #{remote_info}")
    puts
  end

  def git(command)
    @local.repo.git(command)
  end

  def synced?
    @local.hash == @remote.hash
  end
end

CLI.new
