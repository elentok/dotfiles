#!/usr/bin/env ruby

require_relative '../framework'
require 'yaml'
require_or_install_gem 'deluge', 'deluge-rpc'

class CLI
  def main
    case ARGV[0]
    when 'list'
      puts api.torrents
    when 'list-complete'
      puts api.complete_torrents
    when 'remove-complete'
      api.complete_torrents.each do |torrent|
        print "Removing #{torrent}... "
        if api.remove(torrent)
          puts green('done')
        else
          puts red('ERROR')
        end
      end
    else
      usage
    end
  end

  def api
    @api = API.new
  end

  def usage
    puts <<-EOF

    deluge_remote

    Usage:

      deluge_remote list
      deluge_remote list-complete
      deluge_remote remove-complete

    EOF
  end
end

class API
  def initialize
    config = YAML.load_file(File.expand_path('~/.config/deluge_remote.yml'))
    @client = Deluge::Rpc::Client.new(
      login: config['login'],
      password: config['password'])
    @client.connect
  end

  def torrents(filter = {})
    @client.core.get_torrents_status(filter, ['name', 'state', 'hash'])
      .map { |hash, attribs| Torrent.new(attribs) }
  end

  def complete_torrents
    torrents.select { |t| t.complete? }
  end

  def remove(torrent, remove_data = false)
    @client.core.remove_torrent(torrent.hash, remove_data)
  end
end

class Torrent
  attr_reader :hash, :name, :state

  def initialize(attribs)
    @hash = attribs['hash']
    @name = attribs['name']
    @state = attribs['state'].downcase.to_sym
  end

  def to_s
    "#{@state}\t#{@name}"
  end

  def complete?
    @state == :seeding ||
      @state == :complete
  end
end

CLI.new.main
