#!/usr/bin/env ruby

require "#{ENV['DOTF']}/framework.rb"
require 'fileutils'

class Renamer
  def initialize
    @options = parse_cli_options(
      desc: 'Renames filenames',
      usage: 'rename [options] <pattern> <replacement> <file>...',
      min_items: 3,
      options: {
        yes: [ '-y', '--yes', "Don't ask for confirmation" ]
      })

    @pattern = Regexp.new(ARGV.shift, 'g')
    @replacement = ARGV.shift
    @matches = find_matches

    if @matches.empty?
      puts 'No matches'
    else
      @matches.each { |m| m.print }
      puts
      if @options[:yes] || confirm?('Rename?')
        rename!
      end
    end
  end

  private

  def find_matches
    [].tap do |matches|
      ARGV.each do |filename|
        basename = File.basename(filename)
        new_basename = basename.gsub(@pattern, @replacement)
        if basename != new_basename
          matches << Match.new(filename, new_basename)
        end
      end
    end
  end

  def rename!
    @matches.each do |match|
      match.print 'Renaming '
      match.rename!
    end
  end
end

class Match
  def initialize(from_fullpath, to_basename)
    @from_fullpath = from_fullpath
    @to_basename = to_basename
    @from_dirname = File.dirname(from_fullpath)
    @from_basename = File.basename(from_fullpath)
    @to_fullpath = File.join(@from_dirname, @to_basename)
  end

  def indent(prefix)
    ' ' * [prefix.length + @from_dirname.length - 3, 0].max
  end

  def print(prefix = '')
    puts "#{prefix}#{gray(@from_dirname)}/#{@from_basename}"
    puts "#{indent(prefix)} => #{blue(@to_basename)}"
  end

  def rename!
    if git?
      system "git mv '#{@from_fullpath}' '#{@to_fullpath}'"
    else
      FileUtils.mv @from_fullpath, @to_fullpath
    end
  end

  def git?
    system("git ls-files --error-unmatch #{@from_fullpath} > /dev/null 2>&1")
  end
end

Renamer.new
