#!/usr/bin/env ruby

require "#{ENV['DOTF']}/framework.rb"
require 'ostruct'
require 'date'
require 'fileutils'
require 'pathname'

def main(source_dir, target_dir)
  analysis = Analysis.new(source_dir, target_dir, verbose: true)
  analysis.analyze
  analysis.print

  puts
  if confirm?('Copy files?', 'yes')
    analysis.copy!
  end
end

class Analysis < OpenStruct
  def initialize(source_dir, target_dir, options = {})
    super(
      source_dir: source_dir,
      target_dir: target_dir,
      verbose:    options[:verbose],
      added:      [],
      modified:   [],
      deleted:    [],
      errors:     [],
      totals:     {})
  end

  def analyze
    puts 'Searching for photos...' if verbose
    t = Time.now
    source_items = find_source_items
    puts "Analyzing #{source_items.length} photos..." if verbose

    source_items.each do |source_item|
      if source_item.is_a? Error
        errors << source_item
        next
      end

      target = find_target(source_item, target_dir)
      pair = Pair.new(source: source_item, target: target,
                      target_root: target_dir)

      if pair.status != :same
        self[pair.status] << pair
        totals[pair.status] ||= 0
        totals[pair.status] += source_item.size
      end
    end

    puts "Took #{(Time.now - t).round(3)}sec" if verbose
    puts
  end

  def find_source_items
    fields = %w(Directory FileName DateTimeOriginal Model
                FocalLengthIn35mmFormat Aperture ExposureTime ISO)

    `exiftool "#{source_dir}" -recurse -ignoreMinorErrors \
      -dateFormat '%Y-%m-%d %H:%M' \
      -printFormat '$#{fields.join(',$')}' \
      2>/dev/null`
    .split("\n")
    .map { |raw| SourceItem.parse(raw) }
  end

  def print
    print_group :added
    print_group :modified
    print_group :deleted

    if errors.any?
      puts "* #{errors.length} error(s):"
      errors.each(&:print)
      puts
    end
  end

  def print_group(name)
    if send(name).empty?
      puts "* No #{name} files"
    else
      list = send(name)
      puts "* #{list.length} #{name} file(s) (#{totals[name] / 1024 / 1024}mb):"
      print_files(list)
      puts
    end
  end

  def print_files(pairs, max = 10)
    if pairs.length > max
      pairs[0..max/2-1].each(&:print)
      puts '    ...'
      pairs[-max/2..-1].each(&:print)
    else
      pairs.each(&:print)
    end
  end

  def copy!
    FileUtils.mkdir_p(target_dir)
    f = open(File.join(target_dir, 'copy.log'), 'a')
    f.puts "# Copy start (#{DateTime.now})"

    added.each do |pair|
      puts "Copying #{pair.target}..."
      FileUtils.mkdir_p(File.dirname(pair.target))
      FileUtils.cp(pair.source.filename, pair.target)
      f.puts pair.source.log_line
    end

    puts "Done."
    f.puts "# Copy complete (#{DateTime.now})"
  ensure
    f.close() unless f.nil?
  end
end

class Error
  def initialize(message)
    @message = message
  end

  def print
    puts "  - #{@message}"
  end
end

class Pair < OpenStruct
  def print
    puts "  - #{target} (#{source.size_mb})"
  end

  def status
    @status ||= identify_status
  end

  private

  def identify_status
    if File.exist?(target)
      File.size(target) == source.size ? :same : :modified
    else
      deleted? ? :deleted : :added
    end
  end

  def deleted?
    log_file = File.join(target_root, 'copy.log')
    return false unless File.exist?(log_file)
    system("grep '^#{source.log_line}' '#{log_file}' > /dev/null")
  end
end


class SourceItem < OpenStruct
  def self.parse(raw)
    return Error.new(raw) if raw.start_with? 'Error:'

    dir, filename, date, model, focal_length, aperture, exposure_time, iso =
      raw.split(',')

    return Error.new("Error: no exif data for #{filename}") if date.nil? || date.length == 0
    date = DateTime.parse(date)

    prefix = [
      date.strftime("%H%M"),
      File.basename(filename, '.*').downcase.gsub(/^_+/, '')
    ].join('-')

    if model
      model = model.downcase.sub('dmc-', '')
        .sub('canon eos ', '').sub(' digital', '')
    end

    if focal_length && focal_length.length > 0
      focal_length.sub!(' ', '')
    else
      focal_length = nil
    end

    if exposure_time
      if exposure_time.include?('/')
        exposure_time = "#{exposure_time.sub('1/', '')}hz"
      else
        exposure_time = "#{exposure_time}s"
      end
    end

    aperture = "f#{aperture.sub(/\.0+/, '')}" if aperture
    iso = "i#{iso}" if iso

    new(
      filename: File.join(dir, filename),
      date:     date,
      prefix:   prefix,
      params:   [model, focal_length, exposure_time, aperture, iso]
                .compact.join('-')
    )
  rescue
    puts "Error parsing #{filename}"
    raise
  end

  def ext
    @ext ||= File.extname(filename).downcase
  end

  def size
    return @size unless @size.nil?
    @size = File.size(filename)
  end

  def size_mb
    @size_mb ||= "#{size / 1024 / 1024}mb"
  end

  def log_line
    @log_line ||= ['>>', date.strftime('%Y-%m-%d'), prefix].join(' ')
  end
end

TARGET_CACHE = {}

def find_target(item, target_dir)
  year_dir = File.join(target_dir, item.date.strftime('%Y'))
  day_dir = File.join(year_dir, item.date.strftime('%m-%d'))
  original_day_dir = day_dir

  if TARGET_CACHE[original_day_dir]
    day_dir = TARGET_CACHE[original_day_dir]
  else
    alternate = find_alternate_day_dir(item, year_dir, day_dir)
    day_dir = alternate if alternate
  end

  TARGET_CACHE[original_day_dir] = day_dir

  if Dir.exists?(day_dir)
    target = find_item_in_target_dir(item, day_dir)
    return target if target
  end

  File.join(day_dir, [item.prefix, item.params].join('-') + item.ext)
end

def find_alternate_day_dir(item, year_dir, day_dir)
  if Dir.exists?(year_dir)
    dir_with_desc = Dir["#{day_dir}*"].first
    if dir_with_desc
      day_dir = dir_with_desc
    else
      dir = find_multi_day_target(item, year_dir)
      day_dir = dir if dir
    end
  end
end

def find_multi_day_target(item, year_dir)
  year = item.date.strftime('%Y')

  Dir[File.join(year_dir, '*')].each do |dir|
    dates = /^[\d\-_]+/.match(File.basename(dir))[0]
    from, to = dates.split('_')
    next unless to

    from_month, _ = from.split('-')
    from = DateTime.parse("#{year}-#{from}")
    if to.include? '-'
      to = DateTime.parse("#{year}-#{to} 23:59:59")
    else
      to = DateTime.parse("#{year}-#{from_month}-#{to} 23:59:59")
    end

    if item.date >= from && item.date <= to
      days = (item.date - from).to_i + 1
      return File.join(dir, "day#{days.to_s.rjust(2, '0')}")
    end
  end

  nil
end

def find_item_in_target_dir(item, dir)
  Dir[File.join(dir, "#{item.prefix}*#{item.ext}")].sort.first
end

main(*ARGV) if __FILE__ == $PROGRAM_NAME
